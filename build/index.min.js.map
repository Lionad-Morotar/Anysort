{"version":3,"file":"index.min.js","sources":["../../src/utils.ts","../../src/config.ts","../../src/sort.ts","../../src/build-in-plugins.ts","../../src/main.ts"],"sourcesContent":["import type { SortableTypeEnum, SortableValue } from './type'\n\nexport const isDev = () => process.env.NODE_ENV === 'development'\n// istanbul ignore next\nexport const warn = (msg: String) => isDev() && console.log(`[WARN] ${msg}`)\nexport const strObj = (obj: Object) => JSON.stringify(obj)\n\nexport const isVoid = (x: SortableValue): boolean => x == undefined\nexport const isVoidType = (x: SortableTypeEnum): boolean => x === 'void'\nexport const getType = (x: SortableValue): SortableTypeEnum | string =>\n  isVoid(x) ? 'void' : Object.prototype.toString.call(x).slice(8, -1).toLowerCase()\nexport const isFn = (x: SortableValue): boolean => getType(x) === 'function'\nexport const notNull = (x: any) => !!x\n\n/**\n * @example\n *    1. walk('a.b')({a:{b:3}}) returns 3\n *    2. walk(['a','b'])({a:{b:3}}) returns 3\n */\nexport const walk = (pathsStore: String | String[]) => (x: any) => {\n  const paths = pathsStore instanceof Array\n    // istanbul ignore next\n    ? pathsStore.slice(0, pathsStore.length)\n    : pathsStore.split('.')\n  let val = x\n  let nextPath: string | null = null\n  while (val && paths.length) {\n    nextPath = paths.shift() as string\n    if (!Object.prototype.hasOwnProperty.call(val, nextPath)) {\n      warn(`cant find path \"${JSON.stringify(pathsStore)}\" in ${strObj(x)}, skip by default`)\n    }\n    val = val[nextPath]\n  }\n  return val\n}\n","import type { AnysortConfiguration } from './type'\n\n// global configuration\nconst config: AnysortConfiguration = {\n  delim: '-',\n  patched: '__ANYSORT_PATCHED__',\n  autoWrap: true,\n  autoSort: true,\n  // TODO restrained type number bigger than zero\n  orders: {\n    number: 1,\n    string: 2,\n    symbol: 3,\n    date: 4,\n    object: 5,\n    function: 6,\n    rest: 7,\n    // if no 'void' provided,\n    // undefined value will be ignored in sort,\n    // null value will be treated as normal unrecognized value\n    void: 8\n  }\n}\n\nexport default config\n","import { getType, warn } from './utils'\nimport config from './config'\n\nimport type { SortFn, SortPlugin, SortableValue, SortableTypeEnum, ComparableValue, SortVal } from './type'\nimport type { MappingFn, ResultFn } from './build-in-plugins'\n\n/**\n * get sorting function based on the type of the value\n * @todo refactor x => comparableValue\n * @todo extensible for custom types\n */\nconst getCompareValue: Record<\n  SortableTypeEnum,\n  // TODO fix type\n  // <T extends { new(): T }>(x: T) => ComparableValue\n  (x: any) => ComparableValue\n> = {\n  void: _ => null,\n  number: Number,\n  string: String,\n  symbol: (x: Symbol): string => x.toString(),\n  date: (x: Date): number => +x,\n  function: (x: Function) => x.name,\n  // The priority of true is greater than false\n  boolean: (x: SortableValue): boolean => !x\n}\n\nconst sortBySameType:\n  (type: SortableTypeEnum | string, a: SortableValue, b: SortableValue) => SortVal | undefined =\n  (type, a, b) => {\n    const getValFn = getCompareValue[type]\n    if (getValFn) {\n      const va = getValFn(a)\n      const vb = getValFn(b)\n      // something interesting:\n      // null < null === false\n      // null > null === false\n      return va === vb ? 0 : (va < vb ? -1 : 1)\n    } else {\n      warn(`cant sort ${a} and ${b}，skip by default`)\n    }\n  }\n\nconst sortByDiffType:\n  (oa: number, ob: number) => SortVal =\n  (oa, ob) => {\n    const minus = oa - ob\n    return minus < 0 ? -1 : 1\n  }\n\nconst sortByTypeOrder: SortFn =\n  (a: SortableValue, b: SortableValue) => {\n    const typeA = getType(a)\n    const typeB = getType(b)\n    const orders = config.orders\n    const oa = orders[typeA] || orders.rest\n    const ob = orders[typeB] || orders.rest\n    const isSameType = oa === ob\n    const isComparable = oa && ob\n    // console.log('[ANYSORT DEBUG]', typeA, typeB, a, b, oa, ob)\n    if (isComparable) {\n      return isSameType\n        ? sortBySameType(typeA, a, b)\n        : sortByDiffType(oa, ob)\n    } else {\n      warn(`cant sort ${a} and ${b}，skip by default`)\n    }\n  }\n\ntype PLMaping = (map: MappingFn) => (fn: SortFn) => SortFn\ntype PLResult = (change: ResultFn) => (fn: SortFn) => SortFn\n\nconst maping: PLMaping = map => fn => (a, b) => fn(map(a), map(b))\nconst result: PLResult = change => fn => (a, b) => change(fn(a, b) as SortVal)\n\nexport default class Sort {\n  pipeline: (\n    | { _type: 'maping', _value: MappingFn }\n    | { _type: 'result', _value: ResultFn }\n  )[]\n\n  constructor () {\n    this.pipeline = []\n  }\n\n  // TODO multi-arguments\n  register (plugin: SortPlugin, arg: string) {\n    plugin(this, arg)\n  }\n\n  /**\n   * its not same as Array.prototype.map in js,\n   * but more like map value a to value b,\n   * array.sort((a, b) => a - b) then becames:\n   * array.sort((a, b) => map(a) - map(b))\n   */\n  map (_value: MappingFn): Sort {\n    this.pipeline.push({ _value, _type: 'maping' })\n    return this\n  }\n\n  /**\n   * becareful, the result plugin should be\n   * the last one in this.pipeline\n   */\n  result (_value: ResultFn): Sort {\n    this.pipeline.push({ _value, _type: 'result' })\n    return this\n  }\n\n  seal (): SortFn {\n    let targetSortFn = sortByTypeOrder\n    this.pipeline.reverse().map(current => {\n      const { _type, _value } = current\n      if (_type === 'maping') targetSortFn = maping(_value)(targetSortFn)\n      if (_type === 'result') targetSortFn = result(_value)(targetSortFn)\n    })\n    return targetSortFn\n  }\n}\n","import Sort from './sort'\nimport { walk } from './utils'\n\nimport type {\n  SortVal,\n  SortPlugin,\n  ComparableValue,\n  PluginNames,\n  PluginNamesWithArg,\n  PluginNamesWithoutArg,\n  PluginNamesWithArgMaybe\n} from './type'\n\n// TODO reduce compiled code size\n// TODO plugin 'remap'\nconst plugins = {\n\n  /* Plugins that change sort argument */\n\n  i: (sort: Sort) => sort.map(x => {\n    if (typeof x === 'string') return x.toLowerCase()\n    else throw new Error('[ANYSORT] \"i\" plugin only works on string')\n  }),\n  is: (sort: Sort, arg: string) => {\n    if (arg !== '') {\n      return sort.map(x => x === arg)\n    } else {\n      throw new Error('[ANYSORT] \"is\" plugin needs an arg')\n    }\n  },\n  nth: (sort: Sort, arg: string) => {\n    if (arg !== '') {\n      return sort.map(x => {\n        if (x instanceof Array) return x[+arg]\n        if (typeof x === 'string') return x[+arg]\n        else throw new Error('[ANYSORT] \"nth\" plugin only works on string or array')\n      })\n    } else {\n      throw new Error('[ANYSORT] \"nth\" plugin need an arg')\n    }\n  },\n  all: (sort: Sort, arg: string) => sort.map(x => {\n    if (arg !== '') {\n      if (x instanceof Array) return x.every(y => String(y) === arg)\n      if (typeof x === 'string') return x === arg\n      else throw new Error('[ANYSORT] \"all\" plugin only works on string or array')\n    } else {\n      throw new Error('[ANYSORT] \"all\" plugin need an arg')\n    }\n  }),\n  has: (sort: Sort, arg: string) => sort.map(x => {\n    if (arg !== '') {\n      if (x instanceof Array) return x.some(y => String(y) === arg)\n      if (typeof x === 'string') return x.includes(arg)\n      else throw new Error('[ANYSORT] \"has\" plugin only works on string or array')\n    } else {\n      throw new Error('[ANYSORT] \"has\" plugin need an arg')\n    }\n  }),\n  not: (sort: Sort, arg = '') => {\n    if (arg !== '') {\n      return sort.map(x => x !== arg)\n    } else {\n      return sort.map(x => !x)\n    }\n  },\n  len: (sort: Sort, arg: string) => {\n    if (arg !== '') {\n      return sort.map(x => {\n        if (x instanceof Array) return (x.length === +arg)\n        if (typeof x === 'string') return (x.length === +arg)\n        else throw new Error('[ANYSORT] \"len\" plugin only works on string or array')\n      })\n    } else {\n      return sort.map(x => {\n        if (x instanceof Array) return x.length\n        if (typeof x === 'string') return x.length\n        else throw new Error('[ANYSORT] \"len\" plugin only works on string or array')\n      })\n    }\n  },\n  get: (sort: Sort, arg: string) => {\n    if (arg !== '') return sort.map(walk(arg))\n    else throw new Error('[ANYSORT] \"get\" plugin must have a string argument')\n  },\n\n  /* Plugins that change sort order directly */\n\n  reverse: (sort: Sort) => sort.result(res => -res as SortVal),\n  rand: (sort: Sort) => sort.result(_ => Math.random() < 0.5 ? -1 : 1),\n\n  /* Plugins for Proxy API */\n\n  result: (sort: Sort) => sort.result(res => res)\n\n}\n\nexport type BuildInPlugins = typeof plugins\nexport type BuildInPluginNames = PluginNames<BuildInPlugins>\nexport type BuildInPluginNamesWithoutArg = PluginNamesWithoutArg<BuildInPlugins>\nexport type BuildInPluginNamesWithArg = PluginNamesWithArg<BuildInPlugins>\nexport type BuildInPluginNamesWithArgMaybe = PluginNamesWithArgMaybe<BuildInPlugins>\n\ntype ReadonlyBuildInPlugins = Readonly<Record<keyof BuildInPlugins, SortPlugin>>\n\n// TODO maybe better types next line\nexport type MappingFn = (x: any) => ComparableValue\nexport type ResultFn = (x: SortVal) => SortVal\n\nexport default plugins as ReadonlyBuildInPlugins\n","import Sort from './sort'\nimport plugins from './build-in-plugins'\nimport config from './config'\nimport { isFn, notNull } from './utils'\n\nimport type { Anysort, AnySortWrapper, SortVal, SortFn, SortStringCMD, SortCMD, isSortPluginObjects } from './type'\nimport type { BuildInPlugins } from './build-in-plugins'\n\n/**\n * generate SortFn from string command\n * @exam 'date-reverse()' would be a valid command,\n *        it would be split into 'date', 'reverse()'  two plugins\n */\nfunction genSortFnFromStr<\n  Plugins,\n  ARR extends unknown[],\n  CMD\n> (ss: SortStringCMD<Plugins, ARR, CMD>) {\n  const sort = new Sort()\n  ss.split(config.delim)\n    .filter(notNull)\n    .map(action => {\n      // if match with parens, it's a plugin, such as is(a)),\n      // else it's a object path such as 'a.b'\n      const matchRes = action.match(/^([^(]+)(\\(([^)]*)\\))?$/)\n      if (matchRes) {\n        const [, name, callable, fnArg] = matchRes\n        callable\n          ? sort.register(plugins[name], fnArg)\n          : sort.register(plugins.get, name)\n      } else {\n        throw new Error(`[ANYSORT] illegal command: ${ss}`)\n      }\n    })\n  return sort.seal()\n}\n\nfunction wrapperProxy<\n  Plugins,\n  ARR extends any[],\n  CMD = ''\n> (arr: ARR): AnySortWrapper<Plugins, ARR> {\n  if (arr[config.patched]) {\n    throw new Error('[ANYSORT] patched arr cant be wrapped again')\n  }\n  let proxy: AnySortWrapper<Plugins, ARR> | null = null\n  const pathStore: string[] = []\n  return (proxy = new Proxy(arr, {\n    get (target, prop: string) {\n      switch (prop) {\n        case config.patched:\n          return true\n        case 'apply':\n          return (...args: SortCMD<Plugins, ARR, CMD>[]) => (factory as Anysort<Plugins>)(target, ...args)\n        default:\n          if (Object.prototype.hasOwnProperty.call(plugins, prop)) {\n            // TODO check typeof arg\n            return (arg: string = '') => {\n              const cmdName = [pathStore.splice(0, pathStore.length).join('.'), prop].join('-')\n              const cmd = `${cmdName}(${String(arg)})`\n              return (factory as Anysort<Plugins>)(target, cmd as SortCMD<Plugins, ARR, CMD>)\n            }\n          }\n          if (prop in target) {\n            return target[prop]\n          }\n          // being considered for deprecation\n          if (prop.includes('_')) {\n            return (arg: string = '') => {\n              const cmdName = [pathStore.splice(0, pathStore.length).join('.'), prop].join('-')\n              const cmd = `${cmdName.replace('_', '()-')}(${String(arg)})`\n              return (factory as Anysort<Plugins>)(target, cmd as SortCMD<Plugins, ARR, CMD>)\n            }\n          }\n          pathStore.push(prop)\n          return proxy\n      }\n    }\n  }) as unknown as AnySortWrapper<Plugins, ARR>)\n}\n\n/**\n * main\n */\nfunction genFactory<Plugins> () {\n  const factory = <ARR extends unknown[], CMD> (arr: ARR, ...cmds: SortCMD<Plugins, ARR, CMD>[]): AnySortWrapper<Plugins, ARR> => {\n    const filteredCMDs = cmds\n      .reduce((h, c) => (h.concat(c)), <SortCMD<Plugins, ARR, CMD>[]>[])\n      .filter(Boolean)\n\n    const isEmptyCMDs = filteredCMDs.length === 0\n    if (isEmptyCMDs && !config.autoSort) {\n      if (config.autoWrap) {\n        return wrapperProxy<Plugins, ARR, CMD>(arr)\n      } else {\n        // !FIXME fix type\n        return arr as AnySortWrapper<Plugins, ARR>\n      }\n    }\n\n    const sortFns = isEmptyCMDs\n      ? [new Sort().seal()]\n      : filteredCMDs.map((x: SortCMD<Plugins, ARR, CMD>, i: number) => {\n        return isFn(x)\n          ? <SortFn<ARR>>x\n          : genSortFnFromStr<Plugins, ARR, CMD>(<SortStringCMD<Plugins, ARR, CMD>>x)\n      })\n\n    const flat:\n      (fns: SortFn<ARR>[]) => SortFn<ARR> =\n      fns => ((a, b) => fns.reduce((sortResult: SortVal, fn: SortFn<ARR>) => (sortResult || fn(a, b)) as SortVal, 0)) as SortFn<ARR>\n    const flattenCMDs = flat(sortFns as SortFn<ARR>[])\n\n    type NormalSort = (a: any, b: any) => number\n    let result = arr.sort(flattenCMDs as NormalSort)\n    if (config.autoWrap) {\n      if (!result[config.patched]) {\n        result = wrapperProxy(result)\n      }\n    }\n\n    return result as AnySortWrapper<Plugins, ARR>\n  }\n  return factory as Anysort<Plugins>\n}\nconst factory = genFactory<BuildInPlugins>()\n\n// install plugins\nconst extendPlugs = <U>(exts: isSortPluginObjects<U>) => {\n  Object.entries(exts).map(([k, v]) => plugins[k] = v)\n  type ExtPlugins = { [K in keyof typeof exts]: typeof exts[K] }\n  return factory as Anysort<ExtPlugins & BuildInPlugins>\n}\n\n/**\n * Module Exports\n */\n;(factory as Anysort<BuildInPlugins>).extends = extendPlugs\n;(factory as Anysort<BuildInPlugins>).wrap = arr => wrapperProxy(arr)\n;(factory as Anysort<BuildInPlugins>).config = config\n\nexport default factory as Anysort<BuildInPlugins>\n"],"names":["warn","msg","process","env","NODE_ENV","console","log","getType","x","undefined","isVoid","Object","prototype","toString","call","slice","toLowerCase","notNull","config","delim","patched","autoWrap","autoSort","orders","number","string","symbol","date","object","function","rest","void","getCompareValue","_","Number","String","name","boolean","sortByTypeOrder","a","b","typeA","typeB","oa","ob","type","getValFn","va","vb","sortBySameType","sortByDiffType","Sort","constructor","this","pipeline","register","plugin","arg","map","_value","push","_type","result","seal","targetSortFn","reverse","current","change","fn","plugins","i","sort","Error","is","nth","Array","all","every","y","has","some","includes","not","len","length","get","pathsStore","paths","split","val","nextPath","shift","hasOwnProperty","JSON","stringify","obj","res","rand","Math","random","wrapperProxy","arr","proxy","pathStore","Proxy","target","prop","args","factory","cmd","splice","join","replace","cmds","filteredCMDs","reduce","h","c","concat","filter","Boolean","isEmptyCMDs","sortFns","isFn","ss","action","matchRes","match","callable","fnArg","genSortFnFromStr","flattenCMDs","fns","sortResult","extends","exts","entries","k","v","wrap"],"mappings":"uOAEO,MAEMA,EAAQC,GAF+B,gBAAzBC,QAAQC,IAAIC,UAESC,QAAQC,IAAI,UAAUL,KAKzDM,EAAWC,GAFF,CAACA,GAAmCC,MAALD,EAGnDE,CAAOF,GAAK,OAASG,OAAOC,UAAUC,SAASC,KAAKN,GAAGO,MAAM,GAAI,GAAGC,cAEzDC,EAAWT,KAAaA,ECT/BU,EAA+B,CACnCC,MAAO,IACPC,QAAS,sBACTC,UAAU,EACVC,UAAU,EAEVC,OAAQ,CACNC,OAAQ,EACRC,OAAQ,EACRC,OAAQ,EACRC,KAAM,EACNC,OAAQ,EACRC,SAAU,EACVC,KAAM,EAINC,KAAM,ICTJC,EAKF,CACFD,KAAME,GAAK,KACXT,OAAQU,OACRT,OAAQU,OACRT,OAASlB,GAAsBA,EAAEK,WACjCc,KAAOnB,IAAqBA,EAC5BqB,SAAWrB,GAAgBA,EAAE4B,KAE7BC,QAAU7B,IAA+BA,GA0BrC8B,EACJ,CAACC,EAAkBC,KACjB,MAAMC,EAAQlC,EAAQgC,GAChBG,EAAQnC,EAAQiC,GAChBjB,EAASL,EAAOK,OAChBoB,EAAKpB,EAAOkB,IAAUlB,EAAOO,KAC7Bc,EAAKrB,EAAOmB,IAAUnB,EAAOO,KAInC,GAFqBa,GAAMC,EAGzB,OAJiBD,IAAOC,EA5B5B,EAACC,EAAMN,EAAGC,KACR,MAAMM,EAAWd,EAAgBa,GACjC,GAAIC,EAAU,CACZ,MAAMC,EAAKD,EAASP,GACdS,EAAKF,EAASN,GAIpB,OAAOO,IAAOC,EAAK,EAAKD,EAAKC,GAAM,EAAI,EAEvChD,EAAK,aAAauC,SAASC,sBAuBvBS,CAAeR,EAAOF,EAAGC,GAjBjC,EAACG,EAAIC,IACWD,EAAKC,EACJ,GAAK,EAAI,EAgBlBM,CAAeP,EAAIC,GAEvB5C,EAAK,aAAauC,SAASC,sBAUnB,MAAOW,EAMnBC,cACEC,KAAKC,SAAW,GAIlBC,SAAUC,EAAoBC,GAC5BD,EAAOH,KAAMI,GASfC,IAAKC,GAEH,OADAN,KAAKC,SAASM,KAAK,CAAED,SAAQE,MAAO,WAC7BR,KAOTS,OAAQH,GAEN,OADAN,KAAKC,SAASM,KAAK,CAAED,SAAQE,MAAO,WAC7BR,KAGTU,OACE,IAAIC,EAAe1B,EAMnB,OALAe,KAAKC,SAASW,UAAUP,KAAIQ,IAC1B,MAAML,MAAEA,EAAKF,OAAEA,GAAWO,EAzCPR,MACAS,EAyCL,WAAVN,IAAoBG,GA1CLN,EA0C2BC,EA1CpBS,GAAM,CAAC7B,EAAGC,IAAM4B,EAAGV,EAAInB,GAAImB,EAAIlB,KA0CHwB,IACxC,WAAVH,IAAoBG,GA1CLG,EA0C2BR,EA1CjBS,GAAM,CAAC7B,EAAGC,IAAM2B,EAAOC,EAAG7B,EAAGC,KA0CJwB,OAEjDA,GCtGX,MAAMK,EAAU,CAIdC,EAAIC,GAAeA,EAAKb,KAAIlD,IAC1B,GAAiB,iBAANA,EAAgB,OAAOA,EAAEQ,cAC/B,MAAM,IAAIwD,MAAM,gDAEvBC,GAAI,CAACF,EAAYd,KACf,GAAY,KAARA,EACF,OAAOc,EAAKb,KAAIlD,GAAKA,IAAMiD,IAE3B,MAAM,IAAIe,MAAM,uCAGpBE,IAAK,CAACH,EAAYd,KAChB,GAAY,KAARA,EACF,OAAOc,EAAKb,KAAIlD,IACd,GAAIA,aAAamE,MAAO,OAAOnE,GAAGiD,GAClC,GAAiB,iBAANjD,EAAgB,OAAOA,GAAGiD,GAChC,MAAM,IAAIe,MAAM,2DAGvB,MAAM,IAAIA,MAAM,uCAGpBI,IAAK,CAACL,EAAYd,IAAgBc,EAAKb,KAAIlD,IACzC,GAAY,KAARiD,EAAY,CACd,GAAIjD,aAAamE,MAAO,OAAOnE,EAAEqE,OAAMC,GAAK3C,OAAO2C,KAAOrB,IAC1D,GAAiB,iBAANjD,EAAgB,OAAOA,IAAMiD,EACnC,MAAM,IAAIe,MAAM,wDAErB,MAAM,IAAIA,MAAM,yCAGpBO,IAAK,CAACR,EAAYd,IAAgBc,EAAKb,KAAIlD,IACzC,GAAY,KAARiD,EAAY,CACd,GAAIjD,aAAamE,MAAO,OAAOnE,EAAEwE,MAAKF,GAAK3C,OAAO2C,KAAOrB,IACzD,GAAiB,iBAANjD,EAAgB,OAAOA,EAAEyE,SAASxB,GACxC,MAAM,IAAIe,MAAM,wDAErB,MAAM,IAAIA,MAAM,yCAGpBU,IAAK,CAACX,EAAYd,EAAM,KACV,KAARA,EACKc,EAAKb,KAAIlD,GAAKA,IAAMiD,IAEpBc,EAAKb,KAAIlD,IAAMA,IAG1B2E,IAAK,CAACZ,EAAYd,IACJ,KAARA,EACKc,EAAKb,KAAIlD,IACd,GAAIA,aAAamE,MAAO,OAAQnE,EAAE4E,UAAY3B,EAC9C,GAAiB,iBAANjD,EAAgB,OAAQA,EAAE4E,UAAY3B,EAC5C,MAAM,IAAIe,MAAM,2DAGhBD,EAAKb,KAAIlD,IACd,GAAIA,aAAamE,MAAO,OAAOnE,EAAE4E,OACjC,GAAiB,iBAAN5E,EAAgB,OAAOA,EAAE4E,OAC/B,MAAM,IAAIZ,MAAM,2DAI3Ba,IAAK,CAACd,EAAYd,KAChB,GAAY,KAARA,EAAY,OAAOc,EAAKb,KH/DX4B,EG+DoB7B,EH/DejD,IACtD,MAAM+E,EAAQD,aAAsBX,MAEhCW,EAAWvE,MAAM,EAAGuE,EAAWF,QAC/BE,EAAWE,MAAM,KACrB,IAAIC,EAAMjF,EACNkF,EAA0B,KAC9B,KAAOD,GAAOF,EAAMH,QAClBM,EAAWH,EAAMI,QACZhF,OAAOC,UAAUgF,eAAe9E,KAAK2E,EAAKC,IAC7C1F,EAAK,mBAAmB6F,KAAKC,UAAUR,UAxBtBS,EAwBgDvF,EAxBhCqF,KAAKC,UAAUC,uBA0BlDN,EAAMA,EAAIC,GA1BQ,IAACK,EA4BrB,OAAON,KGkDA,MAAM,IAAIjB,MAAM,sDHhEL,IAACc,GGqEnBrB,QAAUM,GAAeA,EAAKT,QAAOkC,IAAQA,IAC7CC,KAAO1B,GAAeA,EAAKT,QAAO7B,GAAKiE,KAAKC,SAAW,IAAO,EAAI,IAIlErC,OAASS,GAAeA,EAAKT,QAAOkC,GAAOA,KCxD7C,SAASI,EAINC,GACD,GAAIA,EAAInF,EAAOE,SACb,MAAM,IAAIoD,MAAM,+CAElB,IAAI8B,EAA6C,KACjD,MAAMC,EAAsB,GAC5B,OAAQD,EAAQ,IAAIE,MAAMH,EAAK,CAC7BhB,IAAKoB,EAAQC,GACX,OAAQA,GACN,KAAKxF,EAAOE,QACV,OAAO,EACT,IAAK,QACH,MAAO,IAAIuF,IAAwCC,EAA6BH,KAAWE,GAC7F,QACE,OAAIhG,OAAOC,UAAUgF,eAAe9E,KAAKuD,EAASqC,GAEzC,CAACjD,EAAc,MACpB,MACMoD,EAAM,GADI,CAACN,EAAUO,OAAO,EAAGP,EAAUnB,QAAQ2B,KAAK,KAAML,GAAMK,KAAK,QACnD5E,OAAOsB,MACjC,OAAQmD,EAA6BH,EAAQI,IAG7CH,KAAQD,EACHA,EAAOC,GAGZA,EAAKzB,SAAS,KACT,CAACxB,EAAc,MACpB,MACMoD,EAAM,GADI,CAACN,EAAUO,OAAO,EAAGP,EAAUnB,QAAQ2B,KAAK,KAAML,GAAMK,KAAK,KACtDC,QAAQ,IAAK,UAAU7E,OAAOsB,MACrD,OAAQmD,EAA6BH,EAAQI,KAGjDN,EAAU3C,KAAK8C,GACRJ,OAkDX,MAAAM,EAxCY,CAA8BP,KAAaY,KACzD,MAAMC,EAAeD,EAClBE,QAAO,CAACC,EAAGC,IAAOD,EAAEE,OAAOD,IAAmC,IAC9DE,OAAOC,SAEJC,EAAsC,IAAxBP,EAAa9B,OACjC,GAAIqC,IAAgBvG,EAAOI,SACzB,OAAIJ,EAAOG,SACF+E,EAAgCC,GAGhCA,EAIX,MAAMqB,EAAUD,EACZ,EAAC,IAAItE,GAAOY,QACZmD,EAAaxD,KAAI,CAAClD,EAA+B8D,IJ3FrC,CAAC9D,GAA6C,aAAfD,EAAQC,GI4F5CmH,CAAKnH,GACKA,EA3FzB,SAIGoH,GACD,MAAMrD,EAAO,IAAIpB,EAgBjB,OAfAyE,EAAGpC,MAAMtE,EAAOC,OACboG,OAAOtG,GACPyC,KAAImE,IAGH,MAAMC,EAAWD,EAAOE,MAAM,2BAC9B,IAAID,EAMF,MAAM,IAAItD,MAAM,8BAA8BoD,KANlC,CACZ,MAAS,CAAAxF,EAAM4F,EAAUC,GAASH,EAClCE,EACIzD,EAAKhB,SAASc,EAAQjC,GAAO6F,GAC7B1D,EAAKhB,SAASc,EAAQgB,IAAKjD,OAK9BmC,EAAKR,OAuEFmE,CAAsE1H,KAMxE2H,GADJC,EACuBV,GADdnF,EAAGC,IAAM4F,EAAIjB,QAAO,CAACkB,EAAqBjE,IAAqBiE,GAAcjE,EAAG7B,EAAGC,IAAgB,IAA5G4F,MAIF,IAAItE,EAASuC,EAAI9B,KAAK4D,GAOtB,OANIjH,EAAOG,WACJyC,EAAO5C,EAAOE,WACjB0C,EAASsC,EAAatC,KAInBA,UAgBT8C,EAAoC0B,QATdC,IACtB5H,OAAO6H,QAAQD,GAAM7E,KAAI,EAAE+E,EAAGC,KAAOrE,EAAQoE,GAAKC,IAE3C9B,GAOPA,EAAoC+B,KAAOtC,GAAOD,EAAaC,GAC/DO,EAAoC1F,OAASA"}